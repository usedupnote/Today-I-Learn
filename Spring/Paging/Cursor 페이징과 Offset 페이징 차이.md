## `Offset 페이징 vs Cursor 페이징 차이`

### `Offset 페이징이 무엇일까?`

```sql
SELECT * FROM salaries ORDER BY salary LIMIT n, m;
```

- `n`: Page Number
- `m`: Size

<br>

위와 같이 `LIMIT`에서 몇 번째 페이지(Page Number)부터 몇 개(Size) 가져올 것인지 정하여 쿼리에 작성하는 방법이 `Offset 페이징` 방식이라고 합니다. 

그런데 `Offset 페이징`은 권장하는 방식은 아닌데요. 그 이유들에 대해서 알아보겠습니다.

<br>

### `쿼리 실행 시간이 오래걸릴 수 있다.`

만약 n, m의 수치가 매우 커진다면, 쿼리 실행 시간에 상당히 오래걸립니다. 만약 `LIMIT 200000, 10`으로 작성하게 되면 `2000010`건의 레코드를 읽은 후 `200000`건은 버릭 마지막 10건만 사용자에게 반환하게 됩니다. MySQL 서버는 200010건의 레코드를 읽어야 하기 때문에 쿼리가 느려지는 것입니다.

<br>

## `Count 쿼리가 필요하다.`

Offset 기반으로 페이징을 하게 되면 총 페이지 사이즈를 알아야 하기 때문에 Count 쿼리를 한번 더 실행하게 됩니다. 

> InnoDB 스토리지 엔진을 사용하는 테이블에서는 Where 조건이 없는 COUNT(*) 쿼리라 할지라도 직접 데이터나 인덱스를 읽어야만 레코드 건수를 가져올 수 있기 때문에 큰 테이블에서 COUNT() 함수를 사용하는 작업은 주의해야 한다.

위와 같은 특징이 있기 때문에 Offset 기반은 테이블의 데이터가 많을 수록 DB에 부하를 줄 수 있다는 단점을 가지고 있습니다.

<br>

## `데이터가 중복될 수 있다.`

- 그림 예정

데이터가 조회될 때 최신 글부터 보여지게 될 것인데요. 만약에 사용자가 1페이지의 데이터를 보고 있는데, 새로운 데이터가 막 추가되었다면 어떻게 될까요?

2페이지로 넘어갔을 때 1페이지에서 보았던 데이터가 또 보일 수 있다는 단점이 있습니다.

... 작성 중

<br>

## `Reference`

- [Real MySQL-2 80 ~ 83p]()
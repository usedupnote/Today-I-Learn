# `5장: 카프카 컨슈머`

프로듀서가 메세지를 생성해서 카프카의 토픽으로 메세지를 보내면 그 토픽의 메세지를 가져와서 소비(Consume) 하는 역할을 하는 애플리케이션, 서버 등을 지칭하여 컨슈머라고 한다.

컨슈머의 주요 기능은 특정 파티션을 관리하고 있는 파티션 리더에게 메세지 가져오기 요청을 하는 것이다. 각 요청은 로그의 오프셋을 명시하고 그 위치로부터 로그 메세지를 수신한다. 

컨슈머는 가져올 메세지의 위치를 조정할 수 있고, 필요하다면 이미 가져온 데이터도 다시 가져올 수 있다.

<br>

## `컨슈머 주요 옵션`

### `bootstrap.servers`

카프카 클러스터에 처음 연결을 하기 위한 호스트와 포트 정보로 구성된 리스트 정보를 나타낸다. 아래와 같은 형태로 Broker 엔드포인트를 넣어서 사용한다.

```
kafka-dev1.gyunny.com:8080,kafka-dev2.gyunny.com:8080, 
```

<br>

### `fetch.min.bytes`

한번에 가져올 수 있는 최소 데이터 사이즈이다. 만약 지정한 사이즈보다 작은 경우, 요청에 대해 응답하지 않고 데이터가 누적될 때까지 기다린다.

<br>

### `group.id`

컨슈머가 속한 컨슈머 그룹을 식별하는 식별자이다. 그룹 아이디는 매우 중요하다.

<br>

### `enable.auto.commit`

백그라운드로 주기적으로 오프셋을 커밋한다.

<br>

### `auto.offset.reset`

카프카에서 초기 오프셋이 없거나 현재 오프셋이 더 이상 존재하지 않은 경우(데이터가 삭제)에 다음 옵션으로 리셋한다.

- `earliest`: 가장 초기의 오프셋값으로 설정한다.
- `latest`: 가장 마지막의 오프셋값으로 설정한다.
- `none`: 이전 오프셋값을 찾지 못하면 에러를 나타낸다.

<br>

### `max.poll.records`

단일 호출 poll()에 대한 최대 레코드 수를 조정한다. 

<br>

### `max.poll.interval.ms`

컨슈머가 살아있는지를 체크하기 위해 하트비트를 주기적으로 보내는데, 컨슈머가 계속해서 하트비트만 보내고 실제로 메세지를 가져가지 않는 경우가 있을 수도 있다.

이러한 경우 컨슈머가 무한정 해당 파티션을 점유할 수 없도록 주기적으로 poll을 호출하지 않으면 장애라고 판단하고 컨슈머 그룹에서 제외한 후 다른 컨슈머가 해당 파티션에서 메세지를 가져갈 수 있게 한다.

<br>

### `auto.commit.interval.ms`

주기적으로 오프셋을 커밋하는 시간

<br>

## `컨슈머 그룹`

컨슈머는 카프카 토픽에서 메세지를 읽어오는 역할을 한다. 하나의 토픽에 여러 컨슈머 그룹이 동시에 접속해 메세지를 가져올 수 있다.

컨슈머 그룹은 컨슈머를 확장시킬 수도 있다. 예를들어, 프로듀서가 토픽에 보내는 메세지 속도가 갑자기 증가해 컨슈머가 메세지를 가져가는 속도보다 빨라지게 되는 상황이다.

<img width="537" alt="스크린샷 2023-01-06 오후 8 57 17" src="https://user-images.githubusercontent.com/45676906/211008320-8571486f-3a6d-49ff-8583-6dce2bf6332d.png">

<br>

<img width="537" alt="스크린샷 2023-01-06 오후 8 56 52" src="https://user-images.githubusercontent.com/45676906/211008260-26361af6-e5fd-4be0-8890-db72d2d7d6b3.png">

동일한 컨슈머 그룹 내 컨슈머가 추가되면 위와 같이 파티션 소유권이 바뀌게 된다. (파티션 1 == 컨슈머 2, 파티션 2 == 컨슈머 3)

`이렇게 소유권이 이동하는 것을 리밸런스` 라고 한다. 이러한 컨슈머 그룹의 리밸런스를 통해 컨슈머 그룹에는 컨슈머를 쉽고 안전하게 추가할 수 있고 제거할 수도 있어 높은 가용성과 확장성을 확보할 수 있다.

<br>

### `컨슈머 리밸런스 단점`

리밸런스를 하는 동안 일시적으로 컨슈머는 메세지를 가져올 수 없다. 리밸런스가 발생하면 컨슈머 그룹 전체가 일시적으로 사용 할 수 없다는 단점이 있다. 컨슈머 그룹 내에서 리밸런스가 일어나면 토픽의 각 파티션마다 하나의 컨슈머가 연결된다. 

리밸런스가 끝나게 되면 컨슈머들은 각자 담당하고 있는 파티션으로부터 메세지를 가져오게 된다.

<br>

### `토픽의 파티션에는 하나의 컨슈머만 연결 가능`

위의 그림에서 컨슈머를 하나 더 늘리는 것은 의미가 없다. 왜냐하면 토픽의 파티션에는 하나의 컨슈머만 연결이 가능하기 때문에 컨슈머를 추가해도 메세지를 소비할 수 없기 때문이다.

하나의 파티션에 하나의 컨슈머만 붙을 수 있는 이유는 `각각의 파티션에 대해서는 메세지 순서를 보장하기` 위해서다. 

즉, 컨슈머를 늘리고 싶으면 토픽의 파티션 수를 먼저 늘려야 한다. 

<br>

### `컨슈머의 하트비트`

컨슈머가 컨슈머 그룹 안에서 멤버로 유지하고 할당된 파티션의 소유권을 유지하는 방법은 `하트비트`를 보내는 것이다. 즉, 컨슈머가 일정한 주기로 하트비트를 보낸다는 사실은 해당 파티션의 메세지를 잘 처리하고 있다는 것이다.

`하트비트는 컨슈머가 poll 할 때와 가져간 메세지의 오프셋을 커밋할 때 보내게 된다.` 

만약 컨슈머가 오랫동안 하트비트를 보내지 않으면 세션은 타임아웃되고 해당 컨슈머가 다운되었다고 판단하여 리밸런스가 시작된다.

<br>

### `컨슈머 그룹 특징`

여러 컨슈머 그룹들이 하나의 토픽에서 메세지를 가져갈 수 있는 이유는 컨슈머 그룹마다 각자의 오프셋을 별도로 관리하기 때문에 하나의 토픽에 두 개의 컨슈머 그룹뿐만 아니라 더 많은 컨슈머 그룹이 연결되어도 다른 컨슈머 그룹에게 영향 없이 메세지를 가져갈 수 있기 때문이다.

<br>

## `커밋과 오프셋`

컨슈머가 poll()을 호출할 때마다 컨슈머 그룹은 카프카에 저장되어 있는 아직 읽지 않은 메세지를 가져온다. 컨슈머 그룹의 컨슈머들은 각각의 파티션에 자신이 가져간 메세지의 위치 정보(오프셋)을 기록하고 있다.

각 파티션에 대해 현재 위치(오프셋)를 업데이트하는 동작을 `커밋`한다고 한다.

카프카는 각 컨슈머 그룹의 파티션별로 오프셋 정보를 저장하기 위한 저장소가 별도로 필요하다. 이를 위해 `0.9 이전 버전의 컨슈머는 오프셋 정보를 주키퍼에 저장했지만 성능 등의 문제로 뉴 컨슈머에서는 카프카 내에 별도로 내부에서 사용하논 토픽(_consumer_offsets)을 만들고 그 토픽에 오프셋 정보를 저장하고 있다.`

위에서 컨슈머가 갑자기 다운되거나 컨슈머 그룹에 컨슈머가 새로운 컨슈머가 추가된다면 컨슈머 그룹 내에서 `리밸런스`가 일어난다.

리밸런스가 일어난 후 각각의 컨슈머는 이전에 처리했던 토픽의 파티션이 아닌 다른 새로운 파티션에 할당된다.

만약 커밋된 오프셋이 컨슈머가 실제 마지막으로 처리한 오프셋보다 작으면 마지막 처리된 오프셋과 커밋된 오프셋 사이의 메세지는 중복으로 처리되고, 커밋된 오프셋이 컨슈머가 실제 마지막으로 처리한 오프셋보다 크면 마지막 처리된 오프셋과 커밋된 오프셋 사이의 모든 메세지는 누락된다.

<br>

### `자동 커밋`

오프셋을 직접 관리하는 방법도 있지만, 각 파티션에 대한 오프셋 정보 관리, 파티션 변경에 대한 관리 등이 매우 번거로울 수 있다. 그래서 `enable.auto.commit=true`로 설정하면 5초마다 컨슈머는 `poll()`을 호출할 때 가장 마지막 오프셋을 커밋한다.

5초 주기는 기본 값이며, `auto.commit.interval.ms` 옵션을 통해 조정이 가능하다.

<img width="828" alt="스크린샷 2023-01-07 오후 3 40 55" src="https://user-images.githubusercontent.com/45676906/211135061-fc25f65b-b95f-422e-aa1e-fce9ddaf83c6.png">

그런데 `자동 커밋` 방식을 사용하면 메세지 중복 처리가 될 수 있다는 문제가 있다.

<br>

<img width="637" alt="스크린샷 2023-01-07 오후 3 47 42" src="https://user-images.githubusercontent.com/45676906/211135232-f418f7bd-4f84-46cf-9c5c-40bf81e9ca77.png">

만약 5초가 지나야 커밋이 될 수 있는데 5초가 지나기 전인 3초가 지났을 때 리밸런스가 일어난다면 메세지 중복 처리가 될 수 있다.

예를 들어 메세지 1, 2를 가져온 후에 3초가 지난 시기에 리밸런스가 일어났다면, 이미 메세지 1, 2는 소비가 되었는데 커밋이 되지 않았기 때문에 리밸런스 후에 컨슈머가 다시 1, 2 메세지를 소비하어 중복 메세지 처리가 될 것이다.

이처럼 `자동 커밋` 방식은 매우 편하긴 하지만, 메세지 중복 처리가 발생할 수 있기 때문에 동작 원리에 대해 잘 이해하고 사용해야 한다.

<br>

### `수동 커밋`

수동 커밋은 메세지 처리가 완료될 때까지 메세지를 가져온 것으로 간주되어서는 안 되는 경우에 사용한다.

자동 커밋의 경우 최악의 상황을 가정해보면, 컨슈머가 데이터를 가져온 후에 자동 커밋이 되고 DB에 저장하는 과정에서 에러가 발생했다면, DB에 데이터는 저장하지 못했는데 파티션에 메세지는 커밋이 된 상황이라 메세지가 누락될 위험이 있다.

그래서 수동 커밋을 통해서 DB에 저장된 후에 커밋하도록 할 수 있다. `하지만 수동 커밋의 경우에도 중복이 발생할 수 있다. 메세지들을 데이터베이스에 저장하는 도중에 실패하게 된다면, 마지막 커밋된 오프셋부터 메세지를 다시 가져오기 때문에 일부 메세지들은 데이터베이스에 중복으로 저장될 수 있다.` 

이렇게 카프카에서 메세지는 한 번씩 전달되지만 장애 등의 이유로 중복이 발생할 수 있기 때문에 카프카는 중복은 있지만 손실은 없다를 보장한다.